{"message":"trait objects without an explicit `dyn` are deprecated","code":{"code":"bare_trait_objects","explanation":null},"level":"warning","spans":[{"file_name":"src\\main.rs","byte_start":24,"byte_end":38,"line_start":1,"line_end":1,"column_start":25,"column_end":39,"is_primary":true,"text":[{"text":"fn returns_closure() -> Fn(i32) -> i32 {","highlight_start":25,"highlight_end":39}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`#[warn(bare_trait_objects)]` on by default","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"this was previously accepted by the compiler but is being phased out; it will become a hard error in the 2021 edition!","code":null,"level":"warning","spans":[],"children":[],"rendered":null},{"message":"for more information, see issue #80165 <https://github.com/rust-lang/rust/issues/80165>","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"use `dyn`","code":null,"level":"help","spans":[{"file_name":"src\\main.rs","byte_start":24,"byte_end":38,"line_start":1,"line_end":1,"column_start":25,"column_end":39,"is_primary":true,"text":[{"text":"fn returns_closure() -> Fn(i32) -> i32 {","highlight_start":25,"highlight_end":39}],"label":null,"suggested_replacement":"dyn Fn(i32) -> i32","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;11mwarning\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: trait objects without an explicit `dyn` are deprecated\u001b[0m\n\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0msrc\\main.rs:1:25\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m1\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0mfn returns_closure() -> Fn(i32) -> i32 {\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m                        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;11m^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;11mhelp: use `dyn`: `dyn Fn(i32) -> i32`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m= \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15mnote\u001b[0m\u001b[0m: `#[warn(bare_trait_objects)]` on by default\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m= \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15mwarning\u001b[0m\u001b[0m: this was previously accepted by the compiler but is being phased out; it will become a hard error in the 2021 edition!\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m= \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15mnote\u001b[0m\u001b[0m: for more information, see issue #80165 <https://github.com/rust-lang/rust/issues/80165>\u001b[0m\n\n"}
{"message":"return type cannot have an unboxed trait object","code":{"code":"E0746","explanation":"An unboxed trait object was used as a return value.\n\nErroneous code example:\n\n```compile_fail,E0746\ntrait T {\n    fn bar(&self);\n}\nstruct S(usize);\nimpl T for S {\n    fn bar(&self) {}\n}\n\n// Having the trait `T` as return type is invalid because\n// unboxed trait objects do not have a statically known size:\nfn foo() -> dyn T { // error!\n    S(42)\n}\n```\n\nReturn types cannot be `dyn Trait`s as they must be `Sized`.\n\nTo avoid the error there are a couple of options.\n\nIf there is a single type involved, you can use [`impl Trait`]:\n\n```\n# trait T {\n#     fn bar(&self);\n# }\n# struct S(usize);\n# impl T for S {\n#     fn bar(&self) {}\n# }\n// The compiler will select `S(usize)` as the materialized return type of this\n// function, but callers will only know that the return type implements `T`.\nfn foo() -> impl T { // ok!\n    S(42)\n}\n```\n\nIf there are multiple types involved, the only way you care to interact with\nthem is through the trait's interface, and having to rely on dynamic dispatch\nis acceptable, then you can use [trait objects] with `Box`, or other container\ntypes like `Rc` or `Arc`:\n\n```\n# trait T {\n#     fn bar(&self);\n# }\n# struct S(usize);\n# impl T for S {\n#     fn bar(&self) {}\n# }\nstruct O(&'static str);\nimpl T for O {\n    fn bar(&self) {}\n}\n\n// This now returns a \"trait object\" and callers are only be able to access\n// associated items from `T`.\nfn foo(x: bool) -> Box<dyn T> { // ok!\n    if x {\n        Box::new(S(42))\n    } else {\n        Box::new(O(\"val\"))\n    }\n}\n```\n\nFinally, if you wish to still be able to access the original type, you can\ncreate a new `enum` with a variant for each type:\n\n```\n# trait T {\n#     fn bar(&self);\n# }\n# struct S(usize);\n# impl T for S {\n#     fn bar(&self) {}\n# }\n# struct O(&'static str);\n# impl T for O {\n#     fn bar(&self) {}\n# }\nenum E {\n    S(S),\n    O(O),\n}\n\n// The caller can access the original types directly, but it needs to match on\n// the returned `enum E`.\nfn foo(x: bool) -> E {\n    if x {\n        E::S(S(42))\n    } else {\n        E::O(O(\"val\"))\n    }\n}\n```\n\nYou can even implement the `trait` on the returned `enum` so the callers\n*don't* have to match on the returned value to invoke the associated items:\n\n```\n# trait T {\n#     fn bar(&self);\n# }\n# struct S(usize);\n# impl T for S {\n#     fn bar(&self) {}\n# }\n# struct O(&'static str);\n# impl T for O {\n#     fn bar(&self) {}\n# }\n# enum E {\n#     S(S),\n#     O(O),\n# }\nimpl T for E {\n    fn bar(&self) {\n        match self {\n            E::S(s) => s.bar(),\n            E::O(o) => o.bar(),\n        }\n    }\n}\n```\n\nIf you decide to use trait objects, be aware that these rely on\n[dynamic dispatch], which has performance implications, as the compiler needs\nto emit code that will figure out which method to call *at runtime* instead of\nduring compilation. Using trait objects we are trading flexibility for\nperformance.\n\n[`impl Trait`]: https://doc.rust-lang.org/book/ch10-02-traits.html#returning-types-that-implement-traits\n[trait objects]: https://doc.rust-lang.org/book/ch17-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types\n[dynamic dispatch]: https://doc.rust-lang.org/book/ch17-02-trait-objects.html#trait-objects-perform-dynamic-dispatch\n"},"level":"error","spans":[{"file_name":"src\\main.rs","byte_start":24,"byte_end":38,"line_start":1,"line_end":1,"column_start":25,"column_end":39,"is_primary":true,"text":[{"text":"fn returns_closure() -> Fn(i32) -> i32 {","highlight_start":25,"highlight_end":39}],"label":"doesn't have a size known at compile-time","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for information on `impl Trait`, see <https://doc.rust-lang.org/book/ch10-02-traits.html#returning-types-that-implement-traits>","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"use `impl Fn(i32) -> i32` as the return type, as all return paths are of type `[closure@src\\main.rs:2:3: 2:12]`, which implements `Fn(i32) -> i32`","code":null,"level":"help","spans":[{"file_name":"src\\main.rs","byte_start":24,"byte_end":38,"line_start":1,"line_end":1,"column_start":25,"column_end":39,"is_primary":true,"text":[{"text":"fn returns_closure() -> Fn(i32) -> i32 {","highlight_start":25,"highlight_end":39}],"label":null,"suggested_replacement":"impl Fn(i32) -> i32","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0746]\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: return type cannot have an unboxed trait object\u001b[0m\n\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0msrc\\main.rs:1:25\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m1\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0mfn returns_closure() -> Fn(i32) -> i32 {\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m                        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mdoesn't have a size known at compile-time\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m= \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15mnote\u001b[0m\u001b[0m: for information on `impl Trait`, see <https://doc.rust-lang.org/book/ch10-02-traits.html#returning-types-that-implement-traits>\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: use `impl Fn(i32) -> i32` as the return type, as all return paths are of type `[closure@src\\main.rs:2:3: 2:12]`, which implements `Fn(i32) -> i32`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m1\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0mfn returns_closure() -> impl Fn(i32) -> i32 {\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m                        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m^^^^^^^^^^^^^^^^^^^\u001b[0m\n\n"}
{"message":"aborting due to previous error; 1 warning emitted","code":null,"level":"error","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: aborting due to previous error; 1 warning emitted\u001b[0m\n\n"}
{"message":"For more information about this error, try `rustc --explain E0746`.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;15mFor more information about this error, try `rustc --explain E0746`.\u001b[0m\n"}
